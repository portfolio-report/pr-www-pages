import{N as O,h as d,i as k,O as C,j as z,f as B,g as M}from"./entry.40680b8c.js";const A=()=>null;function j(...r){var h,m,v,D,_,b,g,w,x;const u=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(u);let[a,f,e={}]=r;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof f!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=(h=e.server)!=null?h:!0,e.default=(m=e.default)!=null?m:A,e.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),e.lazy=(D=(v=e.lazy)!=null?v:e.defer)!=null?D:!1,e.initialCache=(_=e.initialCache)!=null?_:!0,e.immediate=(b=e.immediate)!=null?b:!0;const t=O(),c=()=>(t.isHydrating||e.initialCache)&&t.payload.data[a]!==void 0;t._asyncData[a]||(t._asyncData[a]={data:d(c()?t.payload.data[a]:(w=(g=e.default)==null?void 0:g.call(e))!=null?w:null),pending:d(!c()),error:d((x=t.payload._errors[a])!=null?x:null)});const n={...t._asyncData[a]};n.refresh=n.execute=(o={})=>t._asyncDataPromises[a]?t._asyncDataPromises[a]:o._initial&&c()?t.payload.data[a]:(n.pending.value=!0,t._asyncDataPromises[a]=new Promise((s,i)=>{try{s(f(t))}catch(l){i(l)}}).then(s=>{e.transform&&(s=e.transform(s)),e.pick&&(s=E(s,e.pick)),n.data.value=s,n.error.value=null}).catch(s=>{var i,l;n.error.value=s,n.data.value=B((l=(i=e.default)==null?void 0:i.call(e))!=null?l:null)}).finally(()=>{n.pending.value=!1,t.payload.data[a]=n.data.value,n.error.value&&(t.payload._errors[a]=!0),delete t._asyncDataPromises[a]}),t._asyncDataPromises[a]);const y=()=>n.refresh({_initial:!0}),P=e.server!==!1&&t.payload.serverRendered;{const o=M();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const i=o._nuxtOnBeforeMountCbs;o&&(k(()=>{i.forEach(l=>{l()}),i.splice(0,i.length)}),C(()=>i.splice(0,i.length)))}P&&t.isHydrating&&a in t.payload.data?n.pending.value=!1:o&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?o._nuxtOnBeforeMountCbs.push(y):e.immediate&&y(),e.watch&&z(e.watch,()=>n.refresh());const s=t.hook("app:data:refresh",i=>{if(!i||i.includes(a))return n.refresh()});o&&C(s)}const p=Promise.resolve(t._asyncDataPromises[a]).then(()=>n);return Object.assign(p,n),p}function R(...r){const u=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(u);const[a,f,e]=r;return j(a,f,{...e,lazy:!0},null)}function E(r,u){const a={};for(const f of u)a[f]=r[f];return a}export{R as a,j as u};
