import{y as k,i as d,z,A as x,B as O,n as B,C as A}from"./entry.798bb559.js";const M=()=>null;function E(...r){var h,m,v,D,_,b,w,C,g;const u=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(u);let[a,f,e={}]=r;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof f!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=(h=e.server)!=null?h:!0,e.default=(m=e.default)!=null?m:M,e.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),e.lazy=(D=(v=e.lazy)!=null?v:e.defer)!=null?D:!1,e.initialCache=(_=e.initialCache)!=null?_:!0,e.immediate=(b=e.immediate)!=null?b:!0;const t=k(),c=()=>(t.isHydrating||e.initialCache)&&t.payload.data[a]!==void 0;t._asyncData[a]||(t._asyncData[a]={data:d(c()?t.payload.data[a]:(C=(w=e.default)==null?void 0:w.call(e))!=null?C:null),pending:d(!c()),error:d((g=t.payload._errors[a])!=null?g:null)});const n={...t._asyncData[a]};n.refresh=n.execute=(o={})=>t._asyncDataPromises[a]?t._asyncDataPromises[a]:o._initial&&c()?t.payload.data[a]:(n.pending.value=!0,t._asyncDataPromises[a]=new Promise((s,i)=>{try{s(f(t))}catch(l){i(l)}}).then(s=>{e.transform&&(s=e.transform(s)),e.pick&&(s=H(s,e.pick)),n.data.value=s,n.error.value=null}).catch(s=>{var i,l;n.error.value=s,n.data.value=B((l=(i=e.default)==null?void 0:i.call(e))!=null?l:null)}).finally(()=>{n.pending.value=!1,t.payload.data[a]=n.data.value,n.error.value&&(t.payload._errors[a]=!0),delete t._asyncDataPromises[a]}),t._asyncDataPromises[a]);const y=()=>n.refresh({_initial:!0}),P=e.server!==!1&&t.payload.serverRendered;{const o=A();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const i=o._nuxtOnBeforeMountCbs;o&&(z(()=>{i.forEach(l=>{l()}),i.splice(0,i.length)}),x(()=>i.splice(0,i.length)))}P&&t.isHydrating&&a in t.payload.data?n.pending.value=!1:o&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?o._nuxtOnBeforeMountCbs.push(y):e.immediate&&y(),e.watch&&O(e.watch,()=>n.refresh());const s=t.hook("app:data:refresh",i=>{if(!i||i.includes(a))return n.refresh()});o&&x(s)}const p=Promise.resolve(t._asyncDataPromises[a]).then(()=>n);return Object.assign(p,n),p}function j(...r){const u=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(u);const[a,f,e]=r;return E(a,f,{...e,lazy:!0},null)}function H(r,u){const a={};for(const f of u)a[f]=r[f];return a}export{j as a,E as u};
