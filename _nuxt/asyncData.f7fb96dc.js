import{S as P,h as y,N as D,i as x,T as v,j as b,f as w,g as k}from"./entry.b4fff027.js";const C=()=>null;function O(...r){var m;const u=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(u);let[a,c,e={}]=r;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=e.server??!0,e.default=e.default??C,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0;const t=P(),f=()=>t.isHydrating?t.payload.data[a]:t.static.data[a],d=()=>f()!==void 0;t._asyncData[a]||(t._asyncData[a]={data:y(f()??((m=e.default)==null?void 0:m.call(e))??null),pending:y(!d()),error:y(t.payload._errors[a]?D(t.payload._errors[a]):null)});const n={...t._asyncData[a]};n.refresh=n.execute=(i={})=>{if(t._asyncDataPromises[a]){if(i.dedupe===!1)return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if(i._initial&&d())return f();n.pending.value=!0;const l=new Promise((s,o)=>{try{s(c(t))}catch(g){o(g)}}).then(s=>{if(l.cancelled)return t._asyncDataPromises[a];let o=s;e.transform&&(o=e.transform(s)),e.pick&&(o=z(o,e.pick)),n.data.value=o,n.error.value=null}).catch(s=>{var o;if(l.cancelled)return t._asyncDataPromises[a];n.error.value=s,n.data.value=w(((o=e.default)==null?void 0:o.call(e))??null)}).finally(()=>{l.cancelled||(n.pending.value=!1,t.payload.data[a]=n.data.value,n.error.value&&(t.payload._errors[a]=D(n.error.value)),delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=l,t._asyncDataPromises[a]};const p=()=>n.refresh({_initial:!0}),_=e.server!==!1&&t.payload.serverRendered;{const i=k();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const s=i._nuxtOnBeforeMountCbs;i&&(x(()=>{s.forEach(o=>{o()}),s.splice(0,s.length)}),v(()=>s.splice(0,s.length)))}_&&t.isHydrating&&d()?n.pending.value=!1:i&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?i._nuxtOnBeforeMountCbs.push(p):e.immediate&&p(),e.watch&&b(e.watch,()=>n.refresh());const l=t.hook("app:data:refresh",s=>{if(!s||s.includes(a))return n.refresh()});i&&v(l)}const h=Promise.resolve(t._asyncDataPromises[a]).then(()=>n);return Object.assign(h,n),h}function M(...r){const u=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(u);const[a,c,e]=r;return O(a,c,{...e,lazy:!0},null)}function z(r,u){const a={};for(const c of u)a[c]=r[c];return a}export{M as a,O as u};
