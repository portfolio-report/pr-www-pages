import{N as k,h as y,i as z,O as C,j as B,f as M,g as A}from"./entry.6ddbcc5e.js";const j=()=>null;function E(...s){var m,v,D,_,P,b,g,w,x;const f=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(f);let[a,o,e={}]=s;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=(m=e.server)!=null?m:!0,e.default=(v=e.default)!=null?v:j,e.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),e.lazy=(_=(D=e.lazy)!=null?D:e.defer)!=null?_:!1,e.initialCache=(P=e.initialCache)!=null?P:!0,e.immediate=(b=e.immediate)!=null?b:!0;const t=k(),d=()=>(t.isHydrating||e.initialCache)&&t.payload.data[a]!==void 0;t._asyncData[a]||(t._asyncData[a]={data:y(d()?t.payload.data[a]:(w=(g=e.default)==null?void 0:g.call(e))!=null?w:null),pending:y(!d()),error:y((x=t.payload._errors[a])!=null?x:null)});const r={...t._asyncData[a]};r.refresh=r.execute=(i={})=>{if(t._asyncDataPromises[a]){if(i.dedupe===!1)return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if(i._initial&&d())return t.payload.data[a];r.pending.value=!0;const l=new Promise((n,c)=>{try{n(o(t))}catch(u){c(u)}}).then(n=>{if(l.cancelled)return t._asyncDataPromises[a];e.transform&&(n=e.transform(n)),e.pick&&(n=H(n,e.pick)),r.data.value=n,r.error.value=null}).catch(n=>{var c,u;if(l.cancelled)return t._asyncDataPromises[a];r.error.value=n,r.data.value=M((u=(c=e.default)==null?void 0:c.call(e))!=null?u:null)}).finally(()=>{l.cancelled||(r.pending.value=!1,t.payload.data[a]=r.data.value,r.error.value&&(t.payload._errors[a]=!0),delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=l,t._asyncDataPromises[a]};const p=()=>r.refresh({_initial:!0}),O=e.server!==!1&&t.payload.serverRendered;{const i=A();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const n=i._nuxtOnBeforeMountCbs;i&&(z(()=>{n.forEach(c=>{c()}),n.splice(0,n.length)}),C(()=>n.splice(0,n.length)))}O&&t.isHydrating&&a in t.payload.data?r.pending.value=!1:i&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?i._nuxtOnBeforeMountCbs.push(p):e.immediate&&p(),e.watch&&B(e.watch,()=>r.refresh());const l=t.hook("app:data:refresh",n=>{if(!n||n.includes(a))return r.refresh()});i&&C(l)}const h=Promise.resolve(t._asyncDataPromises[a]).then(()=>r);return Object.assign(h,r),h}function I(...s){const f=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(f);const[a,o,e]=s;return E(a,o,{...e,lazy:!0},null)}function H(s,f){const a={};for(const o of f)a[o]=s[o];return a}export{I as a,E as u};
